head(merge(data, min_distance_from_i, by = "id"))
cbind(data, min_distance_from_i)
head(cbind(data, min_distance_from_i))
View((cbind(data, min_distance_from_i))
)
data$id
min_distance_from_i$id
min_distance_from_i$id == data$id
all(min_distance_from_i$id == data$id)
rm(list = ls())
library(osmdata)
library(sf)
library(tidyverse)
# Definisci l'area geografica (esempio: Israele)
area2 <- "Israel"
# Query per luoghi di culto
places_of_worship_i <- opq(bbox = area2) |>
add_osm_feature(key = "amenity", value = "place_of_worship") |>
osmdata_sf()
# Estrai i dati dei punti (nodi)
points2 <- places_of_worship_i$osm_points |>
select(name, geometry) |>
mutate(Latitude = st_coordinates(geometry)[,2],
Longitude = st_coordinates(geometry)[,1]) |>
st_drop_geometry() # Rimuove la colonna geometrica, se non necessaria
# Rimuovi i punti senza nome
filtered_places2 <- points2 |>
filter(!is.na(name)) |>
select(Name = name, Latitude, Longitude)
# Salvataggio dati in un csv
rownames(filtered_places2) <- NULL
filtered_places2$id <- 1:nrow(filtered_places2)
write.csv(filtered_places2, "places_of_worship_israel.csv", row.names = FALSE)
w_isr <- read.csv("places_of_worship_israel.csv")
data <- read.csv("IS_PAL.csv")
xy_j <- as.matrix(w_isr[, c("Latitude", "Longitude")])
library(foreach)
library(doParallel)
# Set up the parallel backend
num_cores <- round(parallel::detectCores()/2)
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# Parallel computation with foreach
min_distance_from_i <- foreach(i = 1:nrow(data), .combine = rbind, .packages = "base") %dopar% {
# Extract coordinates for the i-th row of 'data'
xy_i <- as.numeric(data[i, c("latitude", "longitude")])
distance_from_i <- apply(sweep(xy_j, 2, xy_i, "-"), 1, function(x) sum(sqrt(x^2)))
# Return the index of the minimum distance
c(which.min(distance_from_i), min(distance_from_i))
}
# Stop the parallel backend
stopCluster(cl)
nrow(min_distance_from_i)
rownames(min_distance_from_i) <- NULL
min_distance_from_i <- as.data.frame(min_distance_from_i)
head(min_distance_from_i)
colnames(min_distance_from_i) <- c("nearest_pow", "dist_nearest_pow")
head(min_distance_from_i)
data.frame(data, min_distance_from_i)
data <- data.frame(data, min_distance_from_i)
write.csv(data, "IS_PAL.csv")
head(read.csv("IS_PAL.csv"))
head(min_distance_from_i)
write.csv(min_distance_from_i, "nearest_pow.csv")
data <- data.frame(data, min_distance_from_i)
war <- read.csv("IS_PAL.csv")
war$side_b <- factor(war$side_b)
war$adm_1 <- factor(war$adm_1)
war$event_clarity <- factor(war$event_clarity)
war$date_prec <- factor(war$date_prec)
rmarkdown::paged_table(head(war, 10))
rm(list = ls())
# caricamento librerie
if(!require(tidyverse)) install.packages("tidyverse")
ged241 <- readRDS("ged241.rds")
data <- ged241 |>
filter(conflict_name == "Israel: Palestine" & country == "Israel") |>
select(id, year, side_b, adm_1, latitude, longitude, event_clarity, date_prec,
date_start, date_end, deaths_a, deaths_b, deaths_civilians,
deaths_unknown, best)
data$event_duration <- as.numeric((data$date_end - data$date_start)/(3600*24))
date_start <- data$date_start
date_start <- as.Date(date_start, format = "%Y-%m-%d")
days_since_start <- as.numeric(date_start - min(date_start))
data$days_since_start <- days_since_start
data$intertimes <- c(NA, diff(data$days_since_start))
head(data)
write.csv(data, "IS_PAL.csv")
rm(list = ls())
library(osmdata)
library(sf)
library(tidyverse)
# Definisci l'area geografica (esempio: Israele)
area2 <- "Israel"
# Query per luoghi di culto
places_of_worship_i <- opq(bbox = area2) |>
add_osm_feature(key = "amenity", value = "place_of_worship") |>
osmdata_sf()
# Estrai i dati dei punti (nodi)
points2 <- places_of_worship_i$osm_points |>
select(name, geometry) |>
mutate(Latitude = st_coordinates(geometry)[,2],
Longitude = st_coordinates(geometry)[,1]) |>
st_drop_geometry() # Rimuove la colonna geometrica, se non necessaria
# Rimuovi i punti senza nome
filtered_places2 <- points2 |>
filter(!is.na(name)) |>
select(Name = name, Latitude, Longitude)
# Salvataggio dati in un csv
rownames(filtered_places2) <- NULL
filtered_places2$id <- 1:nrow(filtered_places2)
write.csv(filtered_places2, "places_of_worship_israel.csv", row.names = FALSE)
w_isr <- read.csv("places_of_worship_israel.csv")
data <- read.csv("IS_PAL.csv")
xy_j <- as.matrix(w_isr[, c("Latitude", "Longitude")])
library(foreach)
library(doParallel)
# Set up the parallel backend
num_cores <- round(parallel::detectCores()/2)
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# Parallel computation with foreach
min_distance_from_i <- foreach(i = 1:nrow(data), .combine = rbind, .packages = "base") %dopar% {
# Extract coordinates for the i-th row of 'data'
xy_i <- as.numeric(data[i, c("latitude", "longitude")])
distance_from_i <- apply(sweep(xy_j, 2, xy_i, "-"), 1, function(x) sum(sqrt(x^2)))
# Return the index of the minimum distance
c(which.min(distance_from_i), min(distance_from_i))
}
# Stop the parallel backend
stopCluster(cl)
nrow(min_distance_from_i)
rownames(min_distance_from_i) <- NULL
min_distance_from_i <- as.data.frame(min_distance_from_i)
head(min_distance_from_i)
colnames(min_distance_from_i) <- c("nearest_pow", "dist_nearest_pow")
write.csv(min_distance_from_i, "nearest_pow.csv")
data <- data.frame(data, min_distance_from_i)
head(data)
data <- data.frame(data, min_distance_from_i)[,-1]
head(data)
?write.csv()
data <- data.frame(data, min_distance_from_i)[,-1]
write.csv(data, "IS_PAL.csv", row.names = F)
rm(list = ls())
war <- read.csv("IS_PAL.csv")
head(war)
war$side_b <- factor(war$side_b)
war$adm_1 <- factor(war$adm_1)
war$event_clarity <- factor(war$event_clarity)
war$date_prec <- factor(war$date_prec)
rmarkdown::paged_table(head(war, 10))
hist(war$event_duration)
hist(war$event_duration, breaks = 100, main = "Distribuzione della durata degli eventi")
hist(war$event_duration, breaks = 100, main = "Distribuzione della durata degli eventi", xlab = "durata degli eventi")
hist(war$event_duration, breaks = 1000, main = "Distribuzione della durata degli eventi", xlab = "durata degli eventi")
hist(war$event_duration, breaks = 10, main = "Distribuzione della durata degli eventi", xlab = "durata degli eventi")
hist(war$event_duration, breaks = 50, main = "Distribuzione della durata degli eventi", xlab = "durata degli eventi")
hist(war$event_duration, main = "Distribuzione della durata degli eventi", xlab = "durata degli eventi")
hist(war$event_duration[war$event_duration!=0])
hist(war$event_duration[war$event_duration!=0], main = "Distribuzione della durata degli eventi (tolti quelli con durata 0)", xlab = "durata degli eventi")
hist(war$event_duration[war$event_duration!=0], main = "Distribuzione della durata degli eventi
(tolti quelli con durata 0)", xlab = "durata degli eventi")
addmargins(table(war$event_clarity[war$event_duration!=0],
war$event_duration[war$event_duration!=0]))
#89 eventi su 4181 non si concludono nello stesso giorno, 52 degli 89 eventi si
#sono conclusi il giorno successivo a quello di inizio
#
#distribuzione di event_clarity condizionatamente a date_prec
ggplot(data = war) +
geom_bar(mapping = aes(x = event_clarity, fill = date_prec), position = "fill")
#morti per anno
fatalities <- war |>
group_by(year) |>
summarise(fatalities_per_year = sum(best))
ggplot(fatalities, aes(x = year, y = fatalities_per_year)) +
geom_line(color = "black", linewidth = 1) +  # Linea blu
geom_point(color = "red", size = 2) + # Punti rossi per enfatizzare i dati
labs(title = "Serie Storica dei morti per Anno",
x = "Anno",
y = "Fatalità") +
theme_minimal()
#morti per anno
fatalities <- war |>
group_by(year) |>
summarise(fatalities_per_year = sum(best))
fatalities
ggplot(fatalities, aes(x = year, y = fatalities_per_year)) +
geom_line(color = "black", linewidth = 1) +  # Linea blu
geom_point(color = "red", size = 2) + # Punti rossi per enfatizzare i dati
labs(title = "Serie Storica dei morti per Anno",
x = "Anno",
y = "Fatalità") +
theme_minimal()
filtered_war <- war |>
filter(event_duration!=0)
ggplot(filtered_war, aes(x = event_duration, fill = event_clarity)) +
geom_density(alpha = 0.7) +
facet_wrap(~ event_clarity) +
labs(
title = "Distribuzione della densità della durata degli eventi per chiarezza",
x = "Durata dell'evento",
y = "Densità")
ggplot(filtered_war, aes(x = event_duration, fill = event_clarity)) +
geom_density(alpha = 0.7) +
facet_wrap(~ event_clarity) +
labs(
title = "Distribuzione della densità della durata degli
eventi per event_clarity",
x = "Durata dell'evento",
y = "Densità")
ggplot(filtered_war, aes(x = event_duration, fill = event_clarity)) +
geom_bar(alpha = 0.7) +
facet_wrap(~ event_clarity)
filtered_war <- war |>
filter(event_duration!=0)
ggplot(filtered_war, aes(x = event_duration, fill = event_clarity)) +
geom_bar(alpha = 0.7) +
facet_wrap(~ event_clarity)
intertimes_table <- table(war$intertimes[-1])
intertimes <- as.integer(names(intertimes_table))
n_total <- sum(intertimes_table)
abs_freq <- as.vector(intertimes_table)
rel_freq <- abs_freq/n_total
cum_freq <- cumsum(rel_freq)
surv <- (1 - cum_freq) + rel_freq
intertimes_distr <- data.frame(intertimes = intertimes, abs_freq = abs_freq,
rel_freq = rel_freq, cum_freq = cum_freq, surv = surv)
ggplot(intertimes_distr, aes(x = intertimes, y = rel_freq)) +
geom_col() + ylab("density") +
xlab("intertimes")
ggplot(intertimes_distr, aes(x = intertimes, y = cum_freq)) +
geom_point(shape = 1) +
geom_line(linewidth = 0.2) + ylab("ecdf") +
xlab("intertimes")
ggplot(intertimes_distr, aes(x = log(intertimes), y = log(surv))) +
geom_point(shape = 1) +
geom_line(linewidth = 0.2) +
ylab("log(survival function)") +
xlab("log(intertimes)") +
geom_smooth(method = "lm", se = FALSE, linewidth = 0.3, color = "red")
x <- war$intertimes[-1]
exp_fit <- MASS::fitdistr(x, "exponential")
teor_distr <- pexp(intertimes_distr$intertimes, rate = exp_fit$estimate)
intertimes_distr$exp <- teor_distr
ggplot(data = intertimes_distr) +
geom_point(aes(x = exp, y = cum_freq), col = "red", pch = 1) +
geom_abline(intercept = 0, slope = 1)
ggplot(data = intertimes_distr) +
geom_point(aes(x = exp, y = cum_freq), col = "red", pch = 1) +
geom_abline(intercept = 0, slope = 1)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(rnaturalearth)
library(rnaturalearthdata)
x <- war$intertimes[-1]
x
summary(x)
rm(list = ls())
# caricamento librerie
if(!require(tidyverse)) install.packages("tidyverse")
ged241 <- readRDS("ged241.rds")
data <- ged241 |>
filter(conflict_name == "Israel: Palestine" & country == "Israel") |>
select(id, year, side_b, adm_1, latitude, longitude, event_clarity, date_prec,
date_start, date_end, deaths_a, deaths_b, deaths_civilians,
deaths_unknown, best)
data$event_duration <- as.numeric((data$date_end - data$date_start)/(3600*24))
date_start <- data$date_start
date_start <- as.Date(date_start, format = "%Y-%m-%d")
days_since_start <- as.numeric(date_start - min(date_start))
data$days_since_start <- days_since_start
data$intertimes <- c(NA, diff(data$days_since_start))
summary(data$intertimes)
data <- ged241 |>
filter(conflict_name == "Israel: Palestine" & country == "Israel") |>
select(id, year, side_b, adm_1, latitude, longitude, event_clarity, date_prec,
date_start, date_end, deaths_a, deaths_b, deaths_civilians,
deaths_unknown, best)
head(data)
data$event_duration <- as.numeric((data$date_end - data$date_start)/(3600*24))
date_start <- data$date_start
date_start <- as.Date(date_start, format = "%Y-%m-%d")
days_since_start <- as.numeric(date_start - min(date_start))
data$days_since_start <- days_since_start
data$days_since_start
plot(data$days_since_start)
plot(data$days_since_start)
data$date_start
order(data$date_start)
data[order(data$date_start), ]
data <- data[order(data$date_start), ]
data$event_duration <- as.numeric((data$date_end - data$date_start)/(3600*24))
date_start <- data$date_start
date_start <- as.Date(date_start, format = "%Y-%m-%d")
days_since_start <- as.numeric(date_start - min(date_start))
data$days_since_start <- days_since_start
plot(data$days_since_start)
plot(data$days_since_start)
plot(data$days_since_start)
data$intertimes <- c(NA, diff(data$days_since_start))
head(data)
rm(list = ls())
# caricamento librerie
if(!require(tidyverse)) install.packages("tidyverse")
ged241 <- readRDS("ged241.rds")
data <- ged241 |>
filter(conflict_name == "Israel: Palestine" & country == "Israel") |>
select(id, year, side_b, adm_1, latitude, longitude, event_clarity, date_prec,
date_start, date_end, deaths_a, deaths_b, deaths_civilians,
deaths_unknown, best)
data <- data[order(data$date_start), ]
data$event_duration <- as.numeric((data$date_end - data$date_start)/(3600*24))
date_start <- data$date_start
date_start <- as.Date(date_start, format = "%Y-%m-%d")
days_since_start <- as.numeric(date_start - min(date_start))
data$days_since_start <- days_since_start
plot(data$days_since_start)
data$intertimes <- c(NA, diff(data$days_since_start))
head(data)
write.csv(data, "IS_PAL.csv")
rm(list = ls())
library(osmdata)
library(sf)
library(tidyverse)
# Definisci l'area geografica (esempio: Israele)
area2 <- "Israel"
# Query per luoghi di culto
places_of_worship_i <- opq(bbox = area2) |>
add_osm_feature(key = "amenity", value = "place_of_worship") |>
osmdata_sf()
# Estrai i dati dei punti (nodi)
points2 <- places_of_worship_i$osm_points |>
select(name, geometry) |>
mutate(Latitude = st_coordinates(geometry)[,2],
Longitude = st_coordinates(geometry)[,1]) |>
st_drop_geometry() # Rimuove la colonna geometrica, se non necessaria
# Rimuovi i punti senza nome
filtered_places2 <- points2 |>
filter(!is.na(name)) |>
select(Name = name, Latitude, Longitude)
# Salvataggio dati in un csv
rownames(filtered_places2) <- NULL
filtered_places2$id <- 1:nrow(filtered_places2)
write.csv(filtered_places2, "places_of_worship_israel.csv", row.names = FALSE)
w_isr <- read.csv("places_of_worship_israel.csv")
data <- read.csv("IS_PAL.csv")
xy_j <- as.matrix(w_isr[, c("Latitude", "Longitude")])
library(foreach)
library(doParallel)
# Set up the parallel backend
num_cores <- round(parallel::detectCores()/2)
cl <- makeCluster(num_cores)
registerDoParallel(cl)
# Parallel computation with foreach
min_distance_from_i <- foreach(i = 1:nrow(data), .combine = rbind, .packages = "base") %dopar% {
# Extract coordinates for the i-th row of 'data'
xy_i <- as.numeric(data[i, c("latitude", "longitude")])
distance_from_i <- apply(sweep(xy_j, 2, xy_i, "-"), 1, function(x) sum(sqrt(x^2)))
# Return the index of the minimum distance
c(which.min(distance_from_i), min(distance_from_i))
}
# Stop the parallel backend
stopCluster(cl)
nrow(min_distance_from_i)
rownames(min_distance_from_i) <- NULL
min_distance_from_i <- as.data.frame(min_distance_from_i)
head(min_distance_from_i)
colnames(min_distance_from_i) <- c("nearest_pow", "dist_nearest_pow")
write.csv(min_distance_from_i, "nearest_pow.csv")
data <- data.frame(data, min_distance_from_i)[,-1]
write.csv(data, "IS_PAL.csv", row.names = F)
rm(list = ls())
# caricamento librerie
if(!require(tidyverse)) install.packages("tidyverse")
# if(!require(maps)) install.packages("maps")
# if(!require(mapproj)) install.packages("mapproj")
# if(!require(colorspace)) install.packages("colorspace")
# if(!require(latex2exp)) install.packages("latex2exp")
# if(!require(tmaptools)) install.packages("tmaptools")
# if(!require(sf)) install.packages("sf")
if(!require(stopp)) install.packages("stopp")
if(!require(spatstat)) install.packages("spatstat")
# if(!require(rnaturalearth)) install.packages("rnaturalearth")
# if(!require(rnaturalearthdata)) install.packages("rnaturalearthdata")
war <- read.csv("IS_PAL.csv")
war$side_b <- factor(war$side_b)
war$adm_1 <- factor(war$adm_1)
war$event_clarity <- factor(war$event_clarity)
war$date_prec <- factor(war$date_prec)
rmarkdown::paged_table(head(war, 10))
hist(war$event_duration, main = "Distribuzione della durata degli eventi", xlab = "durata degli eventi")
hist(war$event_duration[war$event_duration!=0], main = "Distribuzione della durata degli eventi
(tolti quelli con durata 0)", xlab = "durata degli eventi")
addmargins(table(war$event_clarity[war$event_duration!=0],
war$event_duration[war$event_duration!=0]))
#89 eventi su 4181 non si concludono nello stesso giorno, 52 degli 89 eventi si
#sono conclusi il giorno successivo a quello di inizio
#
#distribuzione di event_clarity condizionatamente a date_prec
ggplot(data = war) +
geom_bar(mapping = aes(x = event_clarity, fill = date_prec), position = "fill")
#morti per anno
fatalities <- war |>
group_by(year) |>
summarise(fatalities_per_year = sum(best))
ggplot(fatalities, aes(x = year, y = fatalities_per_year)) +
geom_line(color = "black", linewidth = 1) +  # Linea blu
geom_point(color = "red", size = 2) + # Punti rossi per enfatizzare i dati
labs(title = "Serie Storica dei morti per Anno",
x = "Anno",
y = "Fatalità") +
theme_minimal()
#densità di event_duration condizionata a event_clarity
filtered_war <- war |>
filter(event_duration!=0)
#distribuzione di event_duration condizionata a event_clarity
ggplot(filtered_war, aes(x = event_duration, fill = event_clarity)) +
geom_bar(alpha = 0.7) +
facet_wrap(~ event_clarity)
intertimes_table <- table(war$intertimes[-1])
intertimes <- as.integer(names(intertimes_table))
n_total <- sum(intertimes_table)
abs_freq <- as.vector(intertimes_table)
rel_freq <- abs_freq/n_total
cum_freq <- cumsum(rel_freq)
surv <- (1 - cum_freq) + rel_freq
intertimes_distr <- data.frame(intertimes = intertimes, abs_freq = abs_freq,
rel_freq = rel_freq, cum_freq = cum_freq, surv = surv)
ggplot(intertimes_distr, aes(x = intertimes, y = rel_freq)) +
geom_col() + ylab("density") +
xlab("intertimes")
ggplot(intertimes_distr, aes(x = intertimes, y = cum_freq)) +
geom_point(shape = 1) +
geom_line(linewidth = 0.2) + ylab("ecdf") +
xlab("intertimes")
ggplot(intertimes_distr, aes(x = log(intertimes), y = log(surv))) +
geom_point(shape = 1) +
geom_line(linewidth = 0.2) +
ylab("log(survival function)") +
xlab("log(intertimes)") +
geom_smooth(method = "lm", se = FALSE, linewidth = 0.3, color = "red")
x <- war$intertimes[-1]
exp_fit <- MASS::fitdistr(x, "exponential")
teor_distr <- pexp(intertimes_distr$intertimes, rate = exp_fit$estimate)
intertimes_distr$exp <- teor_distr
ggplot(data = intertimes_distr) +
geom_point(aes(x = exp, y = cum_freq), col = "red", pch = 1) +
geom_abline(intercept = 0, slope = 1)
x <- war$intertimes[-1]
exp_fit <- MASS::fitdistr(x, "exponential")
teor_distr <- pexp(intertimes_distr$intertimes, rate = exp_fit$estimate)
intertimes_distr$exp <- teor_distr
ggplot(data = intertimes_distr) +
geom_point(aes(x = exp, y = cum_freq), pch = 1) +
geom_abline(intercept = 0, slope = 1)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(dplyr)
df <- data.frame(x = war$latitude,
y = war$longitude,
t = war$days_since_start,
side_b = war$side_b)
# Load the world map
world <- ne_countries(scale = "medium", returnclass = "sf")
# Define a bounding box for Israel and the surrounding region
# Adjust the range of latitudes and longitudes as necessary
region_bbox <- st_bbox(c(
xmin = 33.0,  # Adjust this for more western longitude
xmax = 37.5,  # Adjust this for more eastern longitude
ymin = 29.5,  # Adjust this for more southern latitude
ymax = 34.5   # Adjust this for more northern latitude
), crs = st_crs(4326))  # WGS84 coordinate reference system
# Crop the world map to the bounding box
region <- st_crop(world, region_bbox)
# Convert df to an sf object
df_sf <- st_as_sf(df, coords = c("y", "x"), crs = 4326)
# Plot the data with the map
p1 <- ggplot() +
geom_sf(data = region, fill = "lightgray", color = "black") +  # Region map
geom_sf(data = df_sf, aes(color = side_b), size = 0.5, alpha = 0.7) +  # Points from df
theme_minimal() +
coord_sf(xlim = c(region_bbox$xmin, region_bbox$xmax),
ylim = c(region_bbox$ymin, region_bbox$ymax),
expand = FALSE) +
labs(title = paste0("Conflict Events in Israel"),
x = "Longitude",
y = "Latitude")
p1
w_isr <- read.csv("places_of_worship_israel.csv", sep = ",")[,-1]
colnames(w_isr) <- c("x", "y")
w_isr
w_isr <- read.csv("places_of_worship_israel.csv", sep = ",")[,-1]
colnames(w_isr) <- c("x", "y")
w_isr
head(w_isr)
w_isr <- read.csv("places_of_worship_israel.csv", sep = ",")[,-1]
head(w_isr)
colnames(w_isr) <- c("x", "y", "id")
w_isr
unique(war$nearest_pow)
w_isr$id == unique(war$nearest_pow)
which(w_isr$id == unique(war$nearest_pow))
w_isr$id %in% unique(war$nearest_pow)
which(w_isr$id %in% unique(war$nearest_pow))
w_isr <- w_isr[which(w_isr$id %in% unique(war$nearest_pow)),]
w_isr
w_isr_sf <- st_as_sf(w_isr, coords = c("y", "x"), crs = 4326)
p1 + geom_sf(data = w_isr_sf, size = 0.7, alpha = 0.25, pch = 3) + labs(subtitle = "Black crosses are places of worship")
